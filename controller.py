import numpy as np
import torch

class AbstractController:
    """ Abstract class of controllers, to be inherited by the other classes
    """
    def __init__(self):
        self.counter = 0
    def reset(self):
        self.counter = 0
    def control(self, x):
        raise NotImplementedError

class RandomController(AbstractController):
    """ Generates random (normal) control actions
    """
    def __init__(self, N, q, mu=0, std=1):
        super().__init__()
        self.N = N
        self.q = q
        self.mu = mu
        self.std = std
    def control(self, x):
        unit_rand = torch.randn((x.size(0), self.N, self.q),
                dtype=torch.double, device=x.device)
        return unit_rand * self.std + self.mu

class ZeroController(AbstractController):
    """ Generates zeros control actions. (So we get the autonomous dynamics)
    """
    def __init__(self, N, q):
        super().__init__()
        self.N = N
        self.q = q
    def control(self, x):
        return torch.zeros((x.size(0), self.N,self.q),
                dtype=torch.double, device=x.device)

class GRNNController(AbstractController):
    """ A Controller wrapper for the parameters generated by our GRNN model
    """
    def __init__(self, model, batch_size):
        super().__init__()
        self.S, self.A, self.B, self.W = model.get_params()
        self.Z = self.A.new_zeros((batch_size, self.S.size(0), self.A.size(1)))
    def control(self, x):
        with torch.no_grad():
            self.Z = torch.tanh(self.S @ self.Z @ self.W + x @ self.A)
            u = self.Z @ self.B
        return u
    def reset(self):
        super().reset()
        self.Z = Z.new_zeros(Z.size())  # Reset the hidden state

'''
class GCNNController(AbstractController):
    def __init__(self, model):
        super().__init__()
        self.S, self.H1, self.H2 = model.get_params()
    def control(self, x):
        kgnn = self.H1.size(0) - 1
        with torch.no_grad():
            z = x @ self.H1[0]
            for i in range(1, kgnn+1):
                z = z + torch.matrix_power(self.S, i) @ x @ self.H1[i]
            z = torch.tanh(z)
            u = self.S @ z @ self.H2[0]
        return u
'''
class GCNNController(AbstractController):
    def __init__(self, model, N):
        super().__init__()
        self.model = model
        self.N = N
    def control(self, x):
        batch_size = x.size(0)
        with torch.no_grad():
            xx = x.reshape(batch_size, 1, 1, self.N)
            uu = self.model.forward(xx).reshape(batch_size, self.N, 1)
        return uu
